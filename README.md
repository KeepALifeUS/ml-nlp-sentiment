# üß† Enterprise NLP Sentiment Analysis for Crypto Trading

**ml-nlp-sentiment** - –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–µ–Ω–Ω–æ-–≥–æ—Ç–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –∞–Ω–∞–ª–∏–∑–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π –¥–ª—è –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–Ω–æ–≥–æ —Ç—Ä–µ–π–¥–∏–Ω–≥–∞ —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π Context7 –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤ –∏ enterprise-grade –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏.

## üöÄ –ö–ª—é—á–µ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏

### ü§ñ Transformer –º–æ–¥–µ–ª–∏

- **BERT Sentiment**: –ë–∞–∑–æ–≤–∞—è –º–æ–¥–µ–ª—å –¥–ª—è –æ–±—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π
- **FinBERT**: –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–æ–¥–µ–ª—å –¥–ª—è —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Ç–µ–∫—Å—Ç–æ–≤
- **RoBERTa**: –†–æ–±—É—Å—Ç–Ω–∞—è –º–æ–¥–µ–ª—å —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π —Å–æ—Ü–∏–∞–ª—å–Ω–æ–π –º–µ–¥–∏–∞ –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π
- **DistilBERT**: –ë—ã—Å—Ç—Ä–∞—è –ª–µ–≥–∫–æ–≤–µ—Å–Ω–∞—è –º–æ–¥–µ–ª—å –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
- **CryptoBERT**: –ö–∞—Å—Ç–æ–º–Ω–∞—è –º–æ–¥–µ–ª—å, –æ–±—É—á–µ–Ω–Ω–∞—è –Ω–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
- **Ensemble Model**: –ê–Ω—Å–∞–º–±–ª—å –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏

### üßπ –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –ø—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞

- Crypto-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è ($BTC, #Bitcoin, –∏ —Ç.–¥.)
- –û–±—Ä–∞–±–æ—Ç–∫–∞ —ç–º–æ–¥–∑–∏ —Å –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ–º —ç–º–æ—Ü–∏–π
- –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å–ª–µ–Ω–≥–∞ –∏ –∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä
- –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π
- –ú–Ω–æ–≥–æ—è–∑—ã—á–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞ —Å –ø–µ—Ä–µ–≤–æ–¥–æ–º

### ‚ö° Enterprise –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏

- Batch –∏ streaming –∏–Ω—Ñ–µ—Ä–µ–Ω—Å
- –ú–æ–¥–µ–ª—å versioning –∏ registry
- A/B —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–µ–π
- Performance monitoring
- Auto-scaling inference
- Distributed training

### üõ°Ô∏è –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç—å

- Comprehensive input validation
- XSS –∏ injection –∑–∞—â–∏—Ç–∞
- Sensitive data detection
- Rate limiting
- Audit logging

## üì¶ –£—Å—Ç–∞–Ω–æ–≤–∫–∞

```bash
# –û—Å–Ω–æ–≤–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞
pip install ml-nlp-sentiment

# –° GPU –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π
pip install ml-nlp-sentiment[gpu]

# –° distributed –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏
pip install ml-nlp-sentiment[distributed]

# –ü–æ–ª–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞
pip install ml-nlp-sentiment[dev,gpu,distributed]

```

## üéØ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

### –ë–∞–∑–æ–≤–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

```python
from ml_nlp_sentiment import BERTSentiment, CryptoBERT, EnsembleModel

# –ü—Ä–æ—Å—Ç–æ–π –∞–Ω–∞–ª–∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π
model = BERTSentiment()
result = model.predict("Bitcoin is going to the moon! üöÄ")
print(f"Sentiment: {result.sentiment_label}, Confidence: {result.confidence}")

# Crypto-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π –∞–Ω–∞–ª–∏–∑
crypto_model = CryptoBERT()
result = crypto_model.predict_crypto(
    "Just bought more $BTC. HODL! üíéüôå",
    assets=["BTC"]
)
print(f"Price prediction: {result['price_movement']['label']}")

```

### Ensemble –∞–Ω–∞–ª–∏–∑

```python
# –°–æ–∑–¥–∞–Ω–∏–µ ensemble –º–æ–¥–µ–ª–∏
ensemble = EnsembleModel(
    model_types=["bert", "finbert", "roberta", "crypto_bert"],
    ensemble_strategy="weighted_voting"
)

# Comprehensive –∞–Ω–∞–ª–∏–∑
results = ensemble.predict_ensemble([
    "Bitcoin looking bullish! Time to buy more üìà",
    "Market is crashing, might be a good time to DCA",
    "$ETH has great potential with upcoming updates"
])

for result in results:
    print(f"Ensemble sentiment: {result.ensemble_sentiment}")
    print(f"Model agreement: {result.ensemble_confidence}")

```

### API —Å–µ—Ä–≤–µ—Ä

```python
from ml_nlp_sentiment.api import SentimentAPI

# –ó–∞–ø—É—Å–∫ REST API
api = SentimentAPI(
    models={"ensemble": ensemble},
    enable_rate_limiting=True,
    enable_monitoring=True
)

api.run(host="0.0.0.0", port=8000)

```

### Streaming –æ–±—Ä–∞–±–æ—Ç–∫–∞

```python
from ml_nlp_sentiment.inference import StreamingPredictor

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ streaming –ø—Ä–µ–¥–∏–∫—Ç–æ—Ä–∞
predictor = StreamingPredictor(
    model=ensemble,
    batch_size=32,
    max_latency_ms=100
)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
async def process_stream():
    async for batch_results in predictor.predict_stream(text_stream):
        for text, result in batch_results:
            print(f"Text: {text[:50]}...")
            print(f"Sentiment: {result.ensemble_sentiment}")

```

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å–∏—Å—Ç–µ–º—ã

### üìÅ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

```

ml-nlp-sentiment/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ models/              # Transformer –º–æ–¥–µ–ª–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bert_sentiment.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ finbert_model.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ roberta_sentiment.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ distilbert_model.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ crypto_bert.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ensemble_model.py
‚îÇ   ‚îú‚îÄ‚îÄ preprocessing/       # –ü—Ä–µ–¥–æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–∞
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ text_cleaner.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tokenizer.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ emoji_handler.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ slang_normalizer.py
‚îÇ   ‚îú‚îÄ‚îÄ features/           # Feature engineering
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tfidf_features.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ word_embeddings.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ crypto_features.py
‚îÇ   ‚îú‚îÄ‚îÄ inference/          # Inference engine
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ batch_predictor.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ streaming_predictor.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ model_server.py
‚îÇ   ‚îú‚îÄ‚îÄ api/               # API endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rest_api.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ grpc_server.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ websocket_api.py
‚îÇ   ‚îú‚îÄ‚îÄ explainability/    # Model explainability
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lime_explainer.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ shap_explainer.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ attention_viz.py
‚îÇ   ‚îî‚îÄ‚îÄ utils/             # –£—Ç–∏–ª–∏—Ç—ã
‚îÇ       ‚îú‚îÄ‚îÄ config.py
‚îÇ       ‚îú‚îÄ‚îÄ logger.py
‚îÇ       ‚îî‚îÄ‚îÄ model_registry.py
‚îî‚îÄ‚îÄ tests/                 # –¢–µ—Å—Ç—ã

```

### üîÑ Pipeline –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

```python
# –ü–æ–ª–Ω—ã–π pipeline
from ml_nlp_sentiment import (
    TextCleaner, CryptoTokenizer, CryptoBERT,
    EnsembleModel, SHAPExplainer
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
cleaner = TextCleaner(crypto_optimized=True)
tokenizer = CryptoTokenizer()
model = EnsembleModel()
explainer = SHAPExplainer()

# –û–±—Ä–∞–±–æ—Ç–∫–∞
text = "Just bought $BTC at the dip! üí∞"
cleaned_text = cleaner.clean(text)
tokens = tokenizer.tokenize(cleaned_text)
result = model.predict(cleaned_text)
explanation = explainer.explain(cleaned_text, result)

print(f"Sentiment: {result.ensemble_sentiment}")
print(f"Key features: {explanation.top_features}")

```

## üéõÔ∏è –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

### YAML –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è

```yaml
# config.yaml
app_name: 'Crypto Sentiment Analysis'
environment: 'production'

models:
  ensemble:
    model_type: 'ensemble'
    strategy: 'weighted_voting'
    models: ['bert', 'finbert', 'roberta', 'crypto_bert']

  crypto_bert:
    model_type: 'crypto_bert'
    model_name_or_path: 'bert-base-uncased'
    crypto_optimized: true
    market_condition_aware: true

preprocessing:
  normalize_crypto_tickers: true
  extract_emoji_sentiment: true
  translate_to_english: false
  supported_languages: ['en', 'es', 'fr', 'de', 'ja']

api:
  host: '0.0.0.0'
  port: 8000
  rate_limit_requests: 1000
  rate_limit_period: 60
  cors_origins: ['*']

logging:
  level: 'INFO'
  structured_logging: true
  log_to_file: true
  prometheus_enabled: true

database:
  host: 'localhost'
  database: 'crypto_sentiment'
  pool_size: 10

redis:
  host: 'localhost'
  database: 0
  max_connections: 100

```

### Environment –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

```bash
# .env —Ñ–∞–π–ª
ENVIRONMENT=production
DEBUG=false

# Model settings
DEFAULT_MODEL=ensemble
MAX_WORKERS=4
BATCH_SIZE=32

# Database
DATABASE_URL=postgresql://user:pass@localhost/crypto_sentiment
REDIS_URL=redis://localhost:6379/0

# API keys
HUGGINGFACE_API_KEY=hf_xxxxx
OPENAI_API_KEY=sk-xxxxx

# Security
SECRET_KEY=your_secret_key_here
JWT_SECRET_KEY=your_jwt_secret_here

# Monitoring
MONITORING_ENABLED=true
METRICS_PORT=9090

```

## üìä –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ –º–µ—Ç—Ä–∏–∫–∏

### Benchmark —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã

| –ú–æ–¥–µ–ª—å        | Accuracy | F1-Score | Latency (ms) | Memory (MB) |
| ------------- | -------- | -------- | ------------ | ----------- |
| BERTSentiment | 0.89     | 0.87     | 45           | 512         |
| FinBERT       | 0.92     | 0.91     | 50           | 520         |
| RoBERTa       | 0.91     | 0.89     | 48           | 530         |
| DistilBERT    | 0.86     | 0.84     | 15           | 256         |
| CryptoBERT    | 0.94     | 0.93     | 52           | 540         |
| Ensemble      | 0.96     | 0.95     | 180          | 2048        |

### Throughput —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

```python
from ml_nlp_sentiment.evaluation import Benchmark

# –ó–∞–ø—É—Å–∫ benchmark
benchmark = Benchmark()
results = benchmark.run_throughput_test(
    model=ensemble,
    batch_sizes=[1, 8, 16, 32, 64],
    num_samples=1000
)

print(f"Max throughput: {results.max_throughput} texts/sec")
print(f"Optimal batch size: {results.optimal_batch_size}")

```

## üîç Explainability –∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è

### SHAP –∞–Ω–∞–ª–∏–∑

```python
from ml_nlp_sentiment.explainability import SHAPExplainer

explainer = SHAPExplainer(model=crypto_model)

# –û–±—ä—è—Å–Ω–µ–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è
text = "Bitcoin is pumping hard! Time to buy more $BTC üöÄ"
explanation = explainer.explain(text)

print("Feature importance:")
for feature, importance in explanation.feature_importance:
    print(f"  {feature}: {importance:.3f}")

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
explanation.plot_waterfall()
explanation.plot_force_plot()

```

### LIME –∞–Ω–∞–ª–∏–∑

```python
from ml_nlp_sentiment.explainability import LIMEExplainer

lime = LIMEExplainer(model=ensemble)
explanation = lime.explain_instance(text, num_features=10)

# HTML –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
explanation.save_to_file('explanation.html')

```

### Attention –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è

```python
from ml_nlp_sentiment.explainability import AttentionVisualizer

viz = AttentionVisualizer(model=bert_model)
attention_map = viz.visualize_attention(
    text="$BTC looking bullish! üìà Time to accumulate",
    layer=11,  # –ü–æ—Å–ª–µ–¥–Ω–∏–π —Å–ª–æ–π
    head=0     # –ü–µ—Ä–≤–∞—è attention head
)

viz.plot_attention_heatmap(attention_map)

```

## üöÄ Deployment –∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ

### Docker deployment

```dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 8000

CMD ["python", "-m", "ml_nlp_sentiment.api", "--host", "0.0.0.0", "--port", "8000"]

```

### Kubernetes deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: crypto-sentiment-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: crypto-sentiment-api
  template:
    metadata:
      labels:
        app: crypto-sentiment-api
    spec:
      containers:
        - name: api
          image: crypto-sentiment:latest
          ports:
            - containerPort: 8000
          env:
            - name: ENVIRONMENT
              value: 'production'
          resources:
            requests:
              memory: '2Gi'
              cpu: '1'
            limits:
              memory: '4Gi'
              cpu: '2'

```

### Load balancing —Å NGINX

```nginx
upstream sentiment_api {
    server localhost:8000;
    server localhost:8001;
    server localhost:8002;
}

server {
    listen 80;
    server_name sentiment.example.com;

    location / {
        proxy_pass http://sentiment_api;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    location /health {
        proxy_pass http://sentiment_api/health;
    }
}

```

## üîß –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã

### –ö–∞—Å—Ç–æ–º–Ω—ã–µ –º–æ–¥–µ–ª–∏

```python
from ml_nlp_sentiment.models import BERTSentiment

class CustomCryptoModel(BERTSentiment):
    """–ö–∞—Å—Ç–æ–º–Ω–∞—è –º–æ–¥–µ–ª—å –¥–ª—è —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        self.setup_custom_components()

    def setup_custom_components(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤"""
        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ custom layers
        self.custom_layer = nn.Linear(768, 256)

    def predict_custom(self, text: str) -> dict:
        """–ö–∞—Å—Ç–æ–º–Ω–∞—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞—Ç–µ–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞"""
        # –í–∞—à–∞ –ª–æ–≥–∏–∫–∞ –∑–¥–µ—Å—å
        pass

```

### –ö–∞—Å—Ç–æ–º–Ω—ã–µ preprocessors

```python
from ml_nlp_sentiment.preprocessing import TextCleaner

class DeFiTextCleaner(TextCleaner):
    """–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π cleaner –¥–ª—è DeFi —Ç–µ–∫—Å—Ç–æ–≤"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # DeFi-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã
        self.defi_patterns = {
            "yield_farming": r"\b(?:yield farm|liquidity mining|farming)\b",
            "defi_protocols": r"\b(?:uniswap|aave|compound|makerdao)\b",
        }

    def clean(self, text: str) -> str:
        """DeFi-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞"""
        cleaned = super().clean(text)

        # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è DeFi —Ç–µ—Ä–º–∏–Ω–æ–≤
        for term_type, pattern in self.defi_patterns.items():
            cleaned = re.sub(pattern, f"[{term_type.upper()}]", cleaned, flags=re.IGNORECASE)

        return cleaned

```

## üìà –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –º–µ—Ç—Ä–∏–∫–∏

### Prometheus –º–µ—Ç—Ä–∏–∫–∏

```python
from prometheus_client import Counter, Histogram, Gauge

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–µ—Ç—Ä–∏–∫
prediction_counter = Counter(
    'sentiment_predictions_total',
    'Total sentiment predictions',
    ['model', 'sentiment']
)

prediction_latency = Histogram(
    'sentiment_prediction_duration_seconds',
    'Sentiment prediction latency'
)

model_accuracy = Gauge(
    'sentiment_model_accuracy',
    'Current model accuracy',
    ['model']
)

# –í –∫–æ–¥–µ –º–æ–¥–µ–ª–∏
@prediction_latency.time()
def predict(self, text):
    result = super().predict(text)

    prediction_counter.labels(
        model=self.model_name,
        sentiment=result.sentiment_label
    ).inc()

    return result

```

### Grafana dashboard

```json
{
  "dashboard": {
    "title": "Crypto Sentiment Analysis",
    "panels": [
      {
        "title": "Predictions per Second",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(sentiment_predictions_total[5m])"
          }
        ]
      },
      {
        "title": "Average Latency",
        "type": "stat",
        "targets": [
          {
            "expr": "avg(sentiment_prediction_duration_seconds)"
          }
        ]
      }
    ]
  }
}

```

## üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### Unit —Ç–µ—Å—Ç—ã

```python
import pytest
from ml_nlp_sentiment import BERTSentiment, CryptoBERT

@pytest.fixture
def bert_model():
    return BERTSentiment(model_name="distilbert-base-uncased")

@pytest.fixture
def crypto_model():
    return CryptoBERT()

def test_basic_sentiment(bert_model):
    """–¢–µ—Å—Ç –±–∞–∑–æ–≤–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π"""
    result = bert_model.predict("I love Bitcoin!")

    assert result.predicted_class in [0, 1, 2]
    assert 0.0 <= result.confidence <= 1.0
    assert result.sentiment_label in ["negative", "neutral", "positive"]

def test_crypto_features(crypto_model):
    """–¢–µ—Å—Ç crypto-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π"""
    text = "$BTC is going to the moon! üöÄ"
    result = crypto_model.predict_crypto(text)

    assert "sentiment" in result
    assert "assets_detected" in result
    assert "BTC" in result["assets_detected"] or "btc" in result["assets_detected"]

@pytest.mark.asyncio
async def test_batch_prediction(bert_model):
    """–¢–µ—Å—Ç batch –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π"""
    texts = [
        "Bitcoin is great!",
        "I hate crypto",
        "Neutral opinion about blockchain"
    ]

    results = bert_model.predict(texts)

    assert len(results) == 3
    assert all(hasattr(r, "confidence") for r in results)

```

### Integration —Ç–µ—Å—Ç—ã

```python
@pytest.mark.integration
def test_full_pipeline():
    """–¢–µ—Å—Ç –ø–æ–ª–Ω–æ–≥–æ pipeline"""
    from ml_nlp_sentiment import TextCleaner, EnsembleModel

    cleaner = TextCleaner()
    model = EnsembleModel()

    raw_text = "OMG!! $BTC is PUMPING!!! üöÄüöÄüöÄ #ToTheMoon"
    cleaned_text = cleaner.clean(raw_text)
    result = model.predict_ensemble(cleaned_text)

    assert result.is_valid
    assert result.ensemble_confidence > 0.5

@pytest.mark.integration
def test_api_endpoints():
    """–¢–µ—Å—Ç API endpoints"""
    from fastapi.testclient import TestClient
    from ml_nlp_sentiment.api import app

    client = TestClient(app)

    response = client.post("/predict", json={
        "text": "Bitcoin is looking bullish!",
        "model": "ensemble"
    })

    assert response.status_code == 200
    data = response.json()
    assert "sentiment" in data
    assert "confidence" in data

```

### Performance —Ç–µ—Å—Ç—ã

```python
@pytest.mark.performance
def test_latency_requirements():
    """–¢–µ—Å—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π –ø–æ latency"""
    import time
    from ml_nlp_sentiment import DistilBERTModel

    model = DistilBERTModel()
    text = "Test text for latency measurement"

    # Warmup
    model.predict(text)

    # Measure latency
    start_time = time.time()
    for _ in range(100):
        model.predict(text)
    avg_latency = (time.time() - start_time) / 100

    # DistilBERT –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±—ã—Å—Ç—Ä–µ–µ 50ms
    assert avg_latency < 0.05

@pytest.mark.performance
def test_throughput_requirements():
    """–¢–µ—Å—Ç —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π –ø–æ throughput"""
    from ml_nlp_sentiment import EnsembleModel

    model = EnsembleModel(parallel_inference=True)
    texts = ["Test text"] * 1000

    start_time = time.time()
    results = model.predict_ensemble(texts)
    duration = time.time() - start_time

    throughput = len(texts) / duration

    # Ensemble –¥–æ–ª–∂–µ–Ω –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å > 50 —Ç–µ–∫—Å—Ç–æ–≤/—Å–µ–∫
    assert throughput > 50

```

## üìö –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

### API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è

–ü–æ–ª–Ω–∞—è API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ –ø–æ –∞–¥—Ä–µ—Å—É `/docs` –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ —Å–µ—Ä–≤–µ—Ä–∞:

```bash
python -m ml_nlp_sentiment.api
# –û—Ç–∫—Ä—ã—Ç—å http://localhost:8000/docs

```

### Jupyter –ø—Ä–∏–º–µ—Ä—ã

```python
# notebooks/crypto_sentiment_analysis.ipynb
import pandas as pd
from ml_nlp_sentiment import CryptoBERT, SHAPExplainer

# –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
df = pd.read_csv("crypto_tweets.csv")

# –ê–Ω–∞–ª–∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π
model = CryptoBERT()
df["sentiment"] = df["text"].apply(lambda x: model.predict_crypto(x)["sentiment"]["label"])

# –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
df.groupby(["date", "sentiment"]).size().unstack().plot(kind="bar", stacked=True)

# Explainability –∞–Ω–∞–ª–∏–∑
explainer = SHAPExplainer(model)
sample_text = df["text"].iloc[0]
explanation = explainer.explain(sample_text)
explanation.plot_waterfall()

```

## ü§ù –ö–æ–Ω—Ç—Ä–∏–±—å—é—à–Ω

### –ù–∞—Å—Ç—Ä–æ–π–∫–∞ dev environment

```bash
# –ö–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
git clone https://github.com/ml-framework/ml-nlp-sentiment.git
cd ml-nlp-sentiment

# –°–æ–∑–¥–∞–Ω–∏–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è
python -m venv venv
source venv/bin/activate  # Linux/Mac
# –∏–ª–∏
venv\Scripts\activate     # Windows

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤ dev —Ä–µ–∂–∏–º–µ
pip install -e .[dev]

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ pre-commit hooks
pre-commit install

```

### –°—Ç–∞–Ω–¥–∞—Ä—Ç—ã –∫–æ–¥–∞

```bash
# –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞
black src/ tests/
isort src/ tests/

# –õ–∏–Ω—Ç–∏–Ω–≥
flake8 src/ tests/
mypy src/ tests/

# –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤
pytest tests/ -v --cov=src/

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
bandit -r src/

```

### Pull Request –ø—Ä–æ—Ü–µ—Å—Å

1. Fork —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
2. –°–æ–∑–¥–∞–Ω–∏–µ feature –≤–µ—Ç–∫–∏: `git checkout -b feature/amazing-feature`
3. –ö–æ–º–º–∏—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π: `git commit -m 'Add amazing feature'`
4. Push –≤ –≤–µ—Ç–∫—É: `git push origin feature/amazing-feature`
5. –û—Ç–∫—Ä—ã—Ç–∏–µ Pull Request

## üìÑ –õ–∏—Ü–µ–Ω–∑–∏—è

MIT License. –°–º. [LICENSE](LICENSE) —Ñ–∞–π–ª –¥–ª—è –¥–µ—Ç–∞–ª–µ–π.

## üÜò –ü–æ–¥–¥–µ—Ä–∂–∫–∞

- üìß Email: <team@ml-framework.dev>
- üí¨ Discord: [ML-Framework Community](https://discord.gg/ml-framework)
- üêõ Issues: [GitHub Issues](https://github.com/ml-framework/ml-nlp-sentiment/issues)
- üìñ Wiki: [Documentation Wiki](https://github.com/ml-framework/ml-nlp-sentiment/wiki)

## üôè –ë–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç–∏

- Hugging Face –∑–∞ transformer models
- OpenAI –∑–∞ inspiration
- Crypto community –∑–∞ feedback –∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
- Context7 team –∑–∞ architectural patterns

---

**Crypto Trading Bot v5.0** - Enterprise NLP Sentiment Analysis  
Made with ‚ù§Ô∏è by ML-Framework Team
